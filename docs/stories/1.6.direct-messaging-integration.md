# Story 1.6: Direct Messaging System Backend Integration

## Status

**Draft**

---

## Story

**As a** user,  
**I want** to send direct messages to colleagues in real-time,  
**so that** I can have private conversations and quick communications.

---

## Acceptance Criteria

1. Users can start new conversations by selecting a colleague from people directory
2. Message creation saves to database with sender, recipient, and timestamp
3. Real-time message delivery: new messages appear instantly without refresh using Supabase real-time
4. Conversation list displays all user's conversations sorted by most recent activity
5. Unread message count badge displays on messaging navigation item
6. Messages within conversation display chronologically with sender/recipient distinction
7. Typing indicators show when the other person is composing a message
8. Read receipts indicate when recipient has seen messages
9. Message search within conversation (find specific messages by content)
10. Users can block/unblock other users to prevent unwanted messages

### Integration Verification

**IV1: Existing Functionality Verification**
- Existing `MessagesPage` layout and conversation list UI unchanged
- Message bubble components continue to display correctly
- Conversation navigation and selection works as before
- Message input form validation behaviour preserved

**IV2: Integration Point Verification**
- Real-time message subscription per conversation (not global subscription)
- Unread count updates in real-time as messages are read/received
- Typing indicator debounced to prevent excessive database writes
- Message history pagination loads older messages efficiently (20 messages per page)

**IV3: Performance Impact Verification**
- Message send latency under 200ms (optimistic UI update)
- Conversation list loads under 500ms (even with 100+ conversations)
- Real-time typing indicator updates do not cause UI jank
- Message history scrolling maintains 60fps with 500+ messages

---

## Dev Technical Guidance

### Prerequisites
**This story depends on Story 1.1 being complete.**
- Database schema with conversations and messages tables
- Authentication working
- Real-time subscription infrastructure

### Relevant Database Tables
[Source: supabase/migrations/20251115000000_complete_schema.sql]

**conversations table:**
```sql
id: uuid (primary key)
created_at: timestamptz
updated_at: timestamptz (updates on new message)
```

**conversation_participants table:**
```sql
id: uuid (primary key)
conversation_id: uuid (foreign key to conversations)
user_id: uuid (foreign key to profiles)
last_read_at: timestamptz (for unread tracking)
UNIQUE(conversation_id, user_id)
```

**messages table:**
```sql
id: uuid (primary key)
conversation_id: uuid (foreign key to conversations)
sender_id: uuid (foreign key to profiles)
content: text
read_at: timestamptz (null if unread)
created_at: timestamptz
```

### Real-Time Messaging Implementation
[Source: Supabase real-time documentation]

**Per-conversation subscription:**
```typescript
const subscription = supabase
  .channel(`conversation:${conversationId}`)
  .on('postgres_changes',
    {
      event: 'INSERT',
      schema: 'public',
      table: 'messages',
      filter: `conversation_id=eq.${conversationId}`
    },
    (payload) => {
      // Add new message to UI
    }
  )
  .subscribe();
```

**Typing indicators (presence):**
```typescript
const channel = supabase.channel(`conversation:${conversationId}`)
  .on('presence', { event: 'sync' }, () => {
    const state = channel.presenceState();
    // Update typing indicators
  })
  .subscribe(async (status) => {
    if (status === 'SUBSCRIBED') {
      await channel.track({ user_id: currentUser.id, typing: true });
    }
  });
```

### Existing Code Context
[Source: brownfield-architecture.md]

**Files to modify:**
- `src/lib/api.ts` - Message CRUD functions
- `src/pages/Messages.tsx` - Conversation list and message UI
- `src/components/messages/ConversationList.tsx` - Conversation display
- `src/components/messages/MessageThread.tsx` - Message display
- `src/components/messages/MessageInput.tsx` - Message composition

**Current state:**
- Messaging UI complete with mock data
- Need real-time integration
- Unread count mechanism exists but not functional

---

## Tasks / Subtasks

- [ ] **Task 1: Implement Conversation and Message API Functions** (AC: 1, 2, 6)
  - [ ] Create `getOrCreateConversation(userId)` function:
    - Check if conversation exists between users
    - Create new conversation if not
    - Add both users as participants
    - Return conversation object
  - [ ] Create `getConversations()` function:
    - Query user's conversations with last message
    - Sort by most recent activity
    - Include unread count per conversation
  - [ ] Create `sendMessage(conversationId, content)` function:
    - Insert message with sender_id
    - Update conversation updated_at
    - Return message object
  - [ ] Create `getMessages(conversationId, page)` function:
    - Query messages with pagination (20 per page)
    - Join sender profiles
    - Order chronologically
  - [ ] Test: create conversation, send message, retrieve messages

- [ ] **Task 2: Real-Time Message Delivery** (AC: 3)
  - [ ] Implement per-conversation real-time subscription:
    - Subscribe to INSERT events on messages table
    - Filter by conversation_id
    - Update UI when new message arrives
  - [ ] Implement subscription cleanup on unmount
  - [ ] Handle edge case: user's own message should not duplicate
  - [ ] Test: multi-browser, send message, verify real-time delivery

- [ ] **Task 3: Unread Count and Read Receipts** (AC: 5, 8)
  - [ ] Implement `markAsRead(conversationId)` function:
    - Update last_read_at in conversation_participants
    - Mark all messages as read (update read_at)
  - [ ] Implement unread count calculation:
    - Count messages since last_read_at
    - Display badge on conversation and navigation
  - [ ] Update read status when conversation opened
  - [ ] Test: send message, verify unread count, open conversation, verify marked read

- [ ] **Task 4: Typing Indicators** (AC: 7)
  - [ ] Implement typing indicator using Supabase presence:
    - Track user typing state in real-time channel
    - Debounce typing events (500ms)
    - Display "User is typing..." indicator
  - [ ] Remove typing indicator after 3 seconds of inactivity
  - [ ] Test: multi-browser, type message, verify typing indicator

- [ ] **Task 5: Message Search** (AC: 9)
  - [ ] Implement `searchMessages(conversationId, query)` function:
    - Full-text search on message content
    - Filter by conversation_id
    - Return matching messages with context
  - [ ] Add search UI to conversation header
  - [ ] Highlight search results in message thread
  - [ ] Test: search for message content, verify results

- [ ] **Task 6: Block/Unblock Users** (AC: 10)
  - [ ] Create blocked_users table if not exists:
    ```sql
    CREATE TABLE blocked_users (
      id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
      blocker_id uuid REFERENCES profiles(id),
      blocked_id uuid REFERENCES profiles(id),
      created_at timestamptz DEFAULT now(),
      UNIQUE(blocker_id, blocked_id)
    );
    ```
  - [ ] Implement `blockUser(userId)` and `unblockUser(userId)` functions
  - [ ] Filter conversations to hide blocked users
  - [ ] Prevent message sending to/from blocked users
  - [ ] Add block/unblock UI to user profile or message header
  - [ ] Test: block user, verify cannot send/receive messages

- [ ] **Task 7: Integration Testing and Performance Validation** (IV1, IV2, IV3)
  - [ ] Verify existing MessagesPage layout unchanged
  - [ ] Verify conversation navigation works
  - [ ] Performance test: message send time (target <200ms optimistic)
  - [ ] Performance test: conversation list load (target <500ms with 100+ conversations)
  - [ ] Performance test: scroll 500+ messages, verify 60fps
  - [ ] Test real-time: no duplicate messages from optimistic UI
  - [ ] Test typing indicator doesn't cause UI jank
  - [ ] Verify per-conversation subscriptions don't leak memory

---

## Dev Notes

**Integration Approach:**
Messaging requires careful real-time subscription management. Each conversation gets its own channel to avoid global subscription overhead. Typing indicators use Supabase presence for ephemeral state.

**Key Technical Decisions:**
1. **Per-conversation channels**: Avoid single global subscription for performance
2. **Presence for typing**: Use ephemeral presence state, not database
3. **Optimistic UI**: Show sent message immediately, confirm asynchronously
4. **Read receipts**: Track last_read_at per user per conversation

**Gotchas to Avoid:**
- Must unsubscribe from message channels on unmount (memory leak)
- Typing indicator must debounce to prevent excessive presence updates
- Own messages should not duplicate (already shown optimistically)
- Blocked users must be filtered at query level (not just UI)

**Testing Strategy:**
- Unit test message CRUD functions
- Integration test real-time message delivery (multi-browser)
- Test typing indicator debouncing and cleanup
- Performance test with 500+ messages
- Test unread count updates in real-time

---

## Dev Agent Record

### Agent Model Used

*To be populated by Dev Agent during implementation*

### Debug Log References

*To be populated by Dev Agent during implementation*

### Completion Notes List

*To be populated by Dev Agent during implementation*

### File List

*To be populated by Dev Agent - List all files created, modified, or deleted during implementation*

---

## Change Log

| Date       | Version | Description                          | Author                |
| ---------- | ------- | ------------------------------------ | --------------------- |
| 2025-01-15 | 1.0     | Initial story creation from PRD Epic 1 | Bob (Scrum Master)  |

